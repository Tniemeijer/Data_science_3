"""
Image to MIDI from: https://github.com/mathigatti/midi2img/
Made some changes to create a midi from an rgb image with three instruments. 
"""


from PIL import Image
import numpy as np
from music21 import instrument, note , chord, stream



def instrument_select(c):
    instr_dict = {0:instrument.Piano(),1:instrument.AcousticBass(),2:instrument.Guitar()}
    return instr_dict[c]

lowerBoundNote = 21
def column2notes(column):
    notes = []
    for i in range(len(column)):
        if column[i] > 255/2:
            notes.append(i+lowerBoundNote)
    return notes

resolution = 0.25
def updateNotes(newNotes,prevNotes): 
    res = {} 
    for note in newNotes:
        if note in prevNotes:
            res[note] = prevNotes[note] + resolution
        else:
            res[note] = resolution
    return res

def image2midi(image_path):
    with Image.open(image_path) as image:
        im_arr = np.frombuffer(image.tobytes(), dtype=np.uint8)
        try:
            im_arr = im_arr.reshape((image.size[1], image.size[0]))
        except:
            im_arr = im_arr.reshape((image.size[1], image.size[0], 3))

    output_notes_per_channel = [[] for _ in range(3)]
    # create note and chord objects based on the values generated by the model
    for c in range(3):
        offset = 0
        prev_notes = updateNotes(im_arr.T[c, 0, :], {})
        for column in im_arr.T[c, 1:, :]:
            notes = column2notes(column)
            # pattern is a chord
            notes_in_chord = notes
            old_notes = prev_notes.keys()
            for old_note in old_notes:
                if not old_note in notes_in_chord:
                    new_note = note.Note(
                        old_note, quarterLength=prev_notes[old_note])
                    new_note.storedInstrument = instrument_select(c)
                    if offset - prev_notes[old_note] >= 0:
                        new_note.offset = offset - prev_notes[old_note]
                        output_notes_per_channel[c].append(new_note)
                    elif offset == 0:
                        new_note.offset = offset
                        output_notes_per_channel[c].append(new_note)
                    else:
                        print(offset, prev_notes[old_note], old_note)

            prev_notes = updateNotes(notes_in_chord, prev_notes)

            # increase offset each iteration so that notes do not stack
            offset += resolution

        # Add the final notes to the MIDI track
        for old_note in prev_notes.keys():
            new_note = note.Note(
                old_note, quarterLength=prev_notes[old_note])
            new_note.storedInstrument = instrument_select(c)
            new_note.offset = offset - prev_notes[old_note]
            output_notes_per_channel[c].append(new_note)

    midi_stream = stream.Stream()
    for i in range(3):  # Use 'i' for track insertion
        # Each channel will have its own instrument track
        track = stream.Part()
        track.insert(instrument_select(i))  # Use 'i' for instrument selection
        for note_obj in output_notes_per_channel[i]:  # Use 'i' to access the corresponding track notes
            track.append(note_obj)
        midi_stream.insert(0, track)

    midi_stream.write('midi', fp=image_path.split("/")[-1].replace(".png", ".mid"))